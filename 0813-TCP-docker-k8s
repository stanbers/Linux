TCP 三次握手：
1. 从最开始双方都处于closed 状态，然后服务器端开始监听某个端口，进入listen 状态；
2. 客户端主动发起连接请求，发送SYN数据包，自己的状态变成了SYN-SENT状态；
3. 服务器收到，返回SYN（对应客户端发来的SYN）和ACK，自己的状态变成了SYN-RECV;
4. 之后客户端再发送ACK 给服务端，自己变成了ESTABLISHED状态，服务端收到ACK 后，也变成了ESTABLISHED 状态
5. 开始传输数据；


TCP 四次挥手：
1. 刚开始双方均处于ESTABLISHED 状态，客户端要断开 了，向服务端发送FIN报文；
2. 发送后，客户端变成了FIN-WAIT-1状态，此时客户端无法再向服务端发关报方，只能接收；
3. 服务端接收后向客户端确认，发送ACK 给客户端，自己变成了CLOSE-WAIT 状态；
4. 客户端收到服务端的确认后，自己变成了FIN-WAIT2状态；
5. 随后，服务端向客户端发送FIN，自己变成了LAST-ACK状态；
6. 客户端收到服务端发来的FIN 后，自己变成了TIME-WAIT状态，然后再发送ACK 给服务端；
7. 此时，客户端需要等待，在这段时间内如果客户端没有再收到服务端的重发请求，表示ACK 成功到达，挥手结束，双方都变成了CLOSED 状态；


docker file 中的指令说明：
from:  以一个镜像作为基础；
copy: 将上下文目录中的指定路径下的文件或文件夹在复制到镜像内指定路径下；
add：在copy 的基础上增加了一些功能，比如是一个tar 压缩文件，复制完后会自动解压，如果源路径是一个URL，docker 引擎会自动把这个URL 文件下载到目标路径下；
volumn: 构建镜像时定义的持久卷；
expose: 声明运行容器服务端口；
workdir: 指定工作目录；
env：设置环境变量；
run: 执行命令；就像在命令行执行命令一样
cmd: 启动容器时，指定运行的程序及参数
entrypoint: 和cmd 一样


如何停止pod :
kubectl scale --replicas=0 deployment/deployment_name

Livenessprobe: 如果查出来这个容器出问题，它会尝试重启这个容器；
readinessprobe: 如果查出来这个容器出问题，它会停止该容器对外提供服务；

像是由多个镜像分层合并而来，而这些层都是只读层。当你启动一个容器，Docker会在最顶部添加读写层，这依赖于写时复制(copy-on-write，简称COW)技术。你在容器内做的所有更改，如写日志、修改、删除文件等，都保存到了读写层内，一般称该层为容器层。

事实上，容器（container）和镜像（image）的最主要区别就是容器加上了顶层的读写层。所有对容器的修改都发生在此层，镜像并不会被修改，因为这些镜像分层的基础镜像可能也在被其他容器使用，一旦修改意味着对其他正在运行的容器也会受到牵连。容器需要读取某个文件时，直接从底部只读层去读即可，而如果需要修改某文件，则将该文件拷贝到顶部读写层进行修改，只读层保持不变。

每个容器都有自己的读写层，因此多个容器可以使用同一个镜像，另外容器被删除时，其对应的读写层也会被删除（如果你希望多个容器共享或者持久化数据，可以使用 Docker volume）。

在执行命令docker ps -s，可以看到最后多了一列SIZE。

关于SIZE相关字段的说明:
 (1)其中size就是容器读写层占用的磁盘空间;
 (2)而括号内的virtual就是再读写层加上对应只读层所占用的磁盘空间。
 
温馨提示:
 如果两个容器是从同一个镜像创建，那么只读层就是100%共享，也就是在服务器上只存在这同一份镜像文件。
 即使不是从同一镜像创建，其镜像仍然可能共享部分只读层（比如共享的镜像是基于另一个镜像创建的）。
 因此，docker实际占用的磁盘空间远远小于virtual的总和。
